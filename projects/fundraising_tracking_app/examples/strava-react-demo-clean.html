<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, orientation=portrait">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com https://cdn-assets.dzcdn.net; style-src 'self' 'unsafe-inline' https://unpkg.com https://cdn-assets.dzcdn.net; img-src 'self' data: https:; connect-src 'self' http://localhost:8000 https://api.strava.com https://api.deezer.com https://widget.deezer.com https://unpkg.com; frame-src 'self' https://widget.deezer.com https://*.deezer.com; object-src 'none'; base-uri 'self';">
    <meta http-equiv="Permissions-Policy" content="accelerometer=(self), gyroscope=(self), magnetometer=(self), camera=(), microphone=(), payment=(), usb=(), serial=(), bluetooth=(), midi=(), sync-xhr=(self), fullscreen=(self), picture-in-picture=(), geolocation=(self), ambient-light-sensor=(self), autoplay=(self), battery=(self), display-capture=(self), document-domain=(self), encrypted-media=(self), execution-while-not-rendered=(self), execution-while-out-of-viewport=(self), focus-without-user-activation=(self), gamepad=(self), layout-animations=(self), legacy-image-formats=(self), oversized-images=(self), payment=(self), picture-in-picture=(self), publickey-credentials-get=(self), speaker-selection=(self), sync-xhr=(self), unoptimized-images=(self), unsized-media=(self), usb=(self), vibrate=(self), wake-lock=(self), xr-spatial-tracking=(self)">
    <title>Strava Activity Demo - All Activities Since May 22, 2025</title>
    <!-- Console suppression removed - focusing on root cause fix -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js?v=2"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 18px;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #fcc;
            margin: 20px 0;
        }
        
        .activity-card {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .activity-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .activity-date {
            color: #666;
            margin-bottom: 15px;
        }
        
        .map-container {
            height: 200px;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px 0;
            border: 2px solid #fc4c02;
        }
        
        .activity-stats {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            display: block;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
        }
        
        .description-section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .description-section h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .description-section p {
            margin: 0;
            color: #555;
        }
        
        .music-section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #ff6b35;
        }
        
        .music-section h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .music-info {
            margin-bottom: 15px;
        }
        
        .music-info p {
            margin: 5px 0;
            color: #555;
        }
        
        .music-widget {
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .music-widget iframe {
            width: 100%;
            height: 300px;
            border: none;
            border-radius: 8px;
        }
        
        .photo-section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .photo-section h4 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .media-container img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .video-thumbnail, .photo-placeholder {
            padding: 20px;
            background: #e9ecef;
            border-radius: 4px;
            text-align: center;
            color: #666;
            border: 2px dashed #ccc;
        }
        
        .comments-section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .comments-section h4 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .comment-item {
            padding: 10px;
            background: white;
            border-radius: 4px;
            margin-bottom: 8px;
            border-left: 3px solid #28a745;
        }
        
        .no-comments {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÉ‚Äç‚ôÇÔ∏èüö¥‚Äç‚ôÇÔ∏è Strava Activities Since May 22, 2025</h1>
        <p class="subtitle">All your Run and Ride activities with animated route maps</p>
        
        <div style="text-align: center; margin-bottom: 20px;">
            <button id="refresh-cache-btn" onclick="refreshCache()" style="
                background: #fc4c02;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: background 0.2s;
            " onmouseover="this.style.background='#e03d00'" onmouseout="this.style.background='#fc4c02'">
                üîÑ Refresh Cache Data
            </button>
            <div id="refresh-status" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
        </div>
        
        <div id="activities-container">
            <div class="loading">üîÑ Loading all activities...</div>
        </div>
    </div>

    <script>
        // Transform processed Strava data to React component format
        function transformStravaToReact(stravaActivity) {
            // Data is already processed by backend - use directly
            const distanceKm = stravaActivity.distance_km || 0;
            const durationMinutes = stravaActivity.duration_minutes || 0;
            const durationHours = durationMinutes / 60;
            
            // Calculate pace for runs or speed for rides
            let paceOrSpeed;
            let paceOrSpeedLabel;
            
            if (stravaActivity.type === 'Run') {
                // Pace (minutes per km) for runs
                const paceMinutes = durationMinutes / distanceKm;
                const paceMinutesInt = Math.floor(paceMinutes);
                const paceSeconds = Math.round((paceMinutes - paceMinutesInt) * 60);
                paceOrSpeed = `${paceMinutesInt}:${paceSeconds.toString().padStart(2, '0')}/km`;
                paceOrSpeedLabel = 'Pace';
            } else if (stravaActivity.type === 'Ride') {
                // Speed (km/h) for rides
                const speedKmh = distanceKm / durationHours;
                paceOrSpeed = `${speedKmh.toFixed(1)} km/h`;
                paceOrSpeedLabel = 'Speed';
            } else {
                // Default to pace for other activities
                const paceMinutes = durationMinutes / distanceKm;
                const paceMinutesInt = Math.floor(paceMinutes);
                const paceSeconds = Math.round((paceMinutes - paceMinutesInt) * 60);
                paceOrSpeed = `${paceMinutesInt}:${paceSeconds.toString().padStart(2, '0')}/km`;
                paceOrSpeedLabel = 'Pace';
            }
            
            // Use time from backend (now shows moving time/duration)
            let time = stravaActivity.time;
            if (!time) {
                // Fallback formatting if backend doesn't provide time
                if (durationHours >= 1) {
                    const hours = Math.floor(durationHours);
                    const minutes = Math.floor(durationMinutes % 60);
                    const seconds = Math.round((durationMinutes - Math.floor(durationMinutes)) * 60);
                    time = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    const minutes = Math.floor(durationMinutes);
                    const seconds = Math.round((durationMinutes - minutes) * 60);
                    time = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }
            
            // Determine media type and get photo URL - only show if there's actual photo data
            const hasMedia = stravaActivity.photos && stravaActivity.photos.primary && stravaActivity.photos.primary.url;
            const mediaType = hasMedia ? (stravaActivity.photos.primary.type === 2 ? "video" : "photo") : "none";
            const mediaIcon = mediaType === "video" ? "üé•" : mediaType === "photo" ? "üì∏" : "";
            const mediaText = mediaType === "video" ? "Video" : mediaType === "photo" ? "Photo" : "No Media";
            const photoUrl = hasMedia && mediaType === "photo" ? 
                (stravaActivity.photos.primary.url || stravaActivity.photos.primary.urls?.['600'] || stravaActivity.photos.primary.urls?.['1000']) : null;
            
            // Use pre-formatted date from backend, or format if needed
            let date = stravaActivity.date;
            if (!date) {
                // Fallback formatting if backend doesn't provide date
                date = formatDate(stravaActivity.start_date_local);
            }
            
            return {
                id: stravaActivity.id,
                title: stravaActivity.name,
                date: date,
                distance: `${distanceKm.toFixed(1)} km`,
                time: time,
                pace: paceOrSpeed,
                paceLabel: paceOrSpeedLabel,
                type: stravaActivity.type,
                mediaType: mediaType,
                mediaIcon: mediaIcon,
                mediaText: mediaText,
                description: stravaActivity.description,
                photoUrl: photoUrl,
                comments: stravaActivity.comment_count || 0,
                music: stravaActivity.music || null
            };
        }

        // Format date for display
        function formatDate(dateString) {
            // Strava's start_date_local is actually UTC but represents local time
            // We need to treat it as local time, not UTC
            const date = new Date(dateString.replace('Z', ''));
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            // Format time (HH:MM)
            const time = date.toLocaleTimeString('en-GB', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            });
            
            // Format date (Day Month Year)
            const dateStr = date.toLocaleDateString('en-GB', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
            
            if (date.toDateString() === today.toDateString()) {
                return `Today at ${time}`;
            } else if (date.toDateString() === yesterday.toDateString()) {
                return `Yesterday at ${time}`;
            } else {
                return `${dateStr} at ${time}`;
            }
        }

        // Polyline decoder function
        function decodePolyline(encoded) {
            const points = [];
            let index = 0;
            const len = encoded.length;
            let lat = 0;
            let lng = 0;
            
            while (index < len) {
                let b, shift = 0, result = 0;
                do {
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                const dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lat += dlat;
                
                shift = 0;
                result = 0;
                do {
                    b = encoded.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                const dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
                lng += dlng;
                
                points.push([lat / 1e5, lng / 1e5]);
            }
            return points;
        }

        // Create activity map with animated route
        async function createActivityMap(activityData) {
            const mapContainer = document.getElementById(`activity-map-${activityData.id}`);
            if (!mapContainer) return;
            
            try {
                // Get GPS data from activity data (already included in test data)
                const mapData = activityData.map || {};
                
                // Check for polyline data first, then GPS points
                let routePoints = [];
                if (mapData.polyline) {
                    routePoints = decodePolyline(mapData.polyline);
                } else if (mapData.gps_points && mapData.gps_points.length > 0) {
                    routePoints = mapData.gps_points.map(point => [point.lat, point.lng]);
                }
                
                // Filter out invalid coordinates
                routePoints = routePoints.filter(point => 
                    point && 
                    Array.isArray(point) && 
                    point.length === 2 && 
                    typeof point[0] === 'number' && 
                    typeof point[1] === 'number' &&
                    !isNaN(point[0]) && 
                    !isNaN(point[1]) &&
                    point[0] >= -90 && point[0] <= 90 &&  // Valid latitude
                    point[1] >= -180 && point[1] <= 180   // Valid longitude
                );
                
                if (routePoints.length > 0) {
                    // Create map
                    const map = L.map(mapContainer, {
                        zoomControl: false,
                        dragging: false,
                        touchZoom: false,
                        doubleClickZoom: false,
                        scrollWheelZoom: false,
                        boxZoom: false,
                        keyboard: false
                    });
                    
                    // Try Jawg Dark tiles first, fallback to OpenStreetMap
                    try {
                        const tokenResponse = await fetch('http://localhost:8000/api/strava-integration/jawg-token');
                        const tokenData = await tokenResponse.json();
                        
                        if (tokenData.has_token) {
                            // Use secure proxy for Jawg tiles (token stays server-side) - defaults to dark style
                            L.tileLayer('http://localhost:8000/api/strava-integration/demo/map-tiles/{z}/{x}/{y}', {
                                attribution: '<a href="https://jawg.io" title="Tiles Courtesy of Jawg Maps" target="_blank">&copy; <b>Jawg</b>Maps</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                                minZoom: 0,
                                maxZoom: 22
                            }).addTo(map);
                        } else {
                            throw new Error('No Jawg token available');
                        }
                    } catch (tokenError) {
                        console.log('Jawg token failed, using dark theme fallback');
                        // Fallback to dark-themed tiles (CartoDB Dark)
                        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                            subdomains: 'abcd',
                            maxZoom: 20
                        }).addTo(map);
                    }
                    
                    // Add route (routePoints already decoded from polyline or GPS points)
                    const routeLine = L.polyline(routePoints, {
                        color: '#ff6b35',
                        weight: 4,
                        opacity: 0.9
                    }).addTo(map);
                    
                    // Add animated route drawing
                    animateRoute(routePoints, mapData, map);
                    
                    // Fit map to route
                    if (mapData.bounds) {
                        const bounds = [
                            [mapData.bounds.south, mapData.bounds.west],
                            [mapData.bounds.north, mapData.bounds.east]
                        ];
                        map.fitBounds(bounds, {padding: [10, 10]});
                    } else {
                        map.fitBounds(routeLine.getBounds(), {padding: [10, 10]});
                    }
                } else {
                    // No GPS data - show placeholder
                    mapContainer.innerHTML = `
                        <div class="map-placeholder">
                            üó∫Ô∏è No GPS Data
                            <div style="font-size: 12px; color: #999;">This activity was recorded without GPS</div>
                        </div>
                    `;
                }
            } catch (error) {
                mapContainer.innerHTML = `
                    <div class="map-placeholder">
                        ‚ùå Map Error
                        <div style="font-size: 12px; color: #999;">Failed to load map: ${error.message}</div>
                    </div>
                `;
            }
        }

        // Animate the route drawing from start to finish
        function animateRoute(routePoints, mapData, map) {
            if (routePoints.length < 2) return;
            
            // Create an animated polyline that will grow
            const animatedRoute = L.polyline([], {
                color: '#ff6b35',
                weight: 6,
                opacity: 1.0,
                dashArray: '15, 10'
            }).addTo(map);
            
            // Create a moving dot
            const movingDot = L.circleMarker(routePoints[0], {
                radius: 10,
                fillColor: '#ff6b35',
                color: '#fff',
                weight: 4,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(map);
            
            // Animation controls
            let currentIndex = 0;
            const totalPoints = routePoints.length;
            const animationSpeed = Math.max(10, Math.floor(totalPoints / 100)); // Adjust speed based on route length
            
            let animationInterval = null;
            
            // Animation function
            function animateStep() {
                if (currentIndex < totalPoints) {
                    // Add next point to animated route
                    const currentPoints = routePoints.slice(0, currentIndex + 1);
                    animatedRoute.setLatLngs(currentPoints);
                    
                    // Move the dot to current position
                    movingDot.setLatLng(routePoints[currentIndex]);
                    
                    currentIndex++;
                } else {
                    // Animation complete - restart the loop
                    currentIndex = 0;
                    animatedRoute.setLatLngs([]);
                    movingDot.setLatLng(routePoints[0]);
                }
            }
            
            // Auto-start animation after a short delay
            setTimeout(() => {
                animationInterval = setInterval(animateStep, animationSpeed);
            }, 1000);
        }

        // Manual cache refresh function
        async function refreshCache() {
            const btn = document.getElementById('refresh-cache-btn');
            const status = document.getElementById('refresh-status');
            
            // Disable button and show loading
            btn.disabled = true;
            btn.innerHTML = 'üîÑ Refreshing...';
            status.innerHTML = 'Starting cache refresh...';
            
            try {
                // Note: Manual refresh requires API key - disabled for demo
                status.innerHTML = `‚ÑπÔ∏è Manual refresh is disabled in demo mode. Data will refresh automatically every 6 hours.`;
            } catch (error) {
                console.error('Cache refresh failed:', error);
                status.innerHTML = `‚ùå Refresh failed: ${error.message}`;
            } finally {
                // Re-enable button after 5 seconds
                setTimeout(() => {
                    btn.disabled = false;
                    btn.innerHTML = 'üîÑ Refresh Cache Data';
                    status.innerHTML = '';
                }, 5000);
            }
        }

        // Load all Strava activities since May 22, 2025 (Run and Ride only)
        async function loadAllActivities() {
            try {
                console.log('Loading all activities since May 22, 2025...');
                
                // Get all activities from the feed (no limit = all cached activities)
                const feedResponse = await fetch('http://localhost:8000/api/strava-integration/demo/feed?limit=500');
                
                if (!feedResponse.ok) {
                    throw new Error('Failed to fetch activities feed');
                }
                
                const feedData = await feedResponse.json();
                const activities = feedData.activities || [];
                
                if (activities.length === 0) {
                    throw new Error('No activities found');
                }
                
                // Display all activities
                displayAllActivities(activities);
                
            } catch (error) {
                console.error('Error loading activities:', error);
                document.getElementById('activities-container').innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
            }
        }

        // Display all activities
        async function displayAllActivities(activities) {
            const container = document.getElementById('activities-container');
            container.innerHTML = '<div class="loading">üîÑ Loading activities...</div>';
            
            let activitiesHtml = '';
            
            for (let i = 0; i < activities.length; i++) {
                try {
                    const activity = activities[i];
                    console.log(`Processing activity ${i + 1}:`, activity.name);
                    
                    // Get comments from activity data (already included in test data)
                    const realComments = activity.comments || [];
                    
                    // Transform to React format
                    const reactData = transformStravaToReact(activity);
                    reactData.realComments = realComments;
                    
                    console.log(`Transformed data for ${activity.name}:`, {
                        description: reactData.description,
                        music: reactData.music
                    });
                    
                    // Create activity card
                activitiesHtml += `
                    <div class="activity-card">
                        <div class="activity-title">${reactData.title}</div>
                        <div class="activity-date">${reactData.date}</div>
                        
                        <!-- Map Section -->
                        <div class="map-section">
                            <div class="map-container" id="activity-map-${reactData.id}"></div>
                        </div>
                        
                        <!-- Activity Stats -->
                        <div class="activity-stats">
                            <div class="stat">
                                <span class="stat-value">${reactData.distance}</span>
                                <span class="stat-label">Distance</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">${reactData.time}</span>
                                <span class="stat-label">Time</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">${reactData.pace}</span>
                                <span class="stat-label">${reactData.paceLabel}</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">${reactData.type}</span>
                                <span class="stat-label">Type</span>
                            </div>
                        </div>
                        
                        <!-- Description Section -->
                        ${reactData.description ? `
                            <div class="description-section">
                                <h4>üìù Description</h4>
                                <p>${reactData.description}</p>
                            </div>
                        ` : ''}
                        
                        <!-- Music Section -->
                        ${reactData.music && reactData.music.detected ? `
                            <div class="music-section">
                                <h4>üéµ Music</h4>
                                <div class="music-info">
                                    <p><strong>${reactData.music.detected.title}</strong> by ${reactData.music.detected.artist}</p>
                                    <p><em>${reactData.music.detected.type === 'track' ? 'Russell Radio' : reactData.music.detected.type === 'album' ? 'Album' : 'Playlist'}</em></p>
                                </div>
                                <div class="music-widget">
                                    ${reactData.music.widget_html}
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Photo Section - only show if there's actual photo data -->
                        ${reactData.mediaType !== "none" && reactData.photoUrl ? `
                            <div class="photo-section">
                                <h4>${reactData.mediaIcon} ${reactData.mediaText}</h4>
                                <div class="media-container">
                                    ${reactData.mediaType === "video" ? `
                                        <div class="video-thumbnail">
                                            üé• Video thumbnail - Click to view on Strava
                                        </div>
                                    ` : `
                                        <img src="${reactData.photoUrl}" alt="Activity photo">
                                    `}
                                </div>
                            </div>
                        ` : ''}
                        
                        <!-- Comments Section (only show if there are comments) -->
                        ${reactData.realComments && reactData.realComments.length > 0 ? `
                            <div class="comments-section">
                                <h4>üí¨ Comments (${reactData.realComments.length})</h4>
                                <div class="comments-list">
                                    ${reactData.realComments.map(comment => `
                                        <div class="comment-item">
                                            <strong>${comment.athlete.firstname} ${comment.athlete.lastname}:</strong> ${comment.text}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
                } catch (error) {
                    console.error(`Error processing activity ${i + 1}:`, error);
                    // Continue with next activity instead of stopping
                    continue;
                }
            }
            
            container.innerHTML = activitiesHtml;
            
            // Create maps for all activities after a delay
            setTimeout(() => {
                activities.forEach(activity => {
                    createActivityMap(activity);
                });
            }, 100);
        }
        
        // Load all activities on page load
        window.addEventListener('load', () => {
            loadAllActivities();
        });
    </script>
</body>
</html>
